{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst EventEmitter = require('events');\n\nconst connect = require('../connection/connect');\n\nconst Connection = require('../../cmap/connection').Connection;\n\nconst common = require('./common');\n\nconst makeStateMachine = require('../utils').makeStateMachine;\n\nconst MongoError = require('../error').MongoError;\n\nconst sdamEvents = require('./events');\n\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kLastCheckTime = Symbol('lastCheckTime');\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this.s = {\n      state: STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,\n      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    }); // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    const addressParts = server.description.address.split(':');\n    this.connectOptions = Object.freeze(Object.assign({\n      id: '<monitor>',\n      host: addressParts[0],\n      port: parseInt(addressParts[1], 10),\n      bson: server.s.bson,\n      connectionType: Connection\n    }, server.s.options, this.options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }));\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    monitorServer(this);\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    const remainingTime = heartbeatFrequencyMS - calculateDurationInMs(this[kLastCheckTime]);\n\n    if (remainingTime > minHeartbeatFrequencyMS && this[kMonitorId]) {\n      clearTimeout(this[kMonitorId]);\n      rescheduleMonitoring(this, minHeartbeatFrequencyMS);\n      return;\n    }\n\n    if (this[kMonitorId]) {\n      clearTimeout(this[kMonitorId]);\n    }\n\n    monitorServer(this);\n  }\n\n  close() {\n    if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    this[kCancellationToken].emit('cancel');\n\n    if (this[kMonitorId]) {\n      clearTimeout(this[kMonitorId]);\n    }\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({\n        force: true\n      });\n    }\n\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n\n}\n\nfunction checkServer(monitor, callback) {\n  if (monitor[kConnection] && monitor[kConnection].closed) {\n    monitor[kConnection] = undefined;\n  }\n\n  const start = process.hrtime();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));\n    callback(err);\n  }\n\n  function successHandler(isMaster) {\n    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), isMaster, monitor.address));\n    return callback(undefined, isMaster);\n  }\n\n  if (monitor[kConnection] != null) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    monitor[kConnection].command('admin.$cmd', {\n      ismaster: true\n    }, {\n      socketTimeout: connectTimeoutMS\n    }, (err, result) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      successHandler(result.result);\n    });\n    return;\n  } // connecting does an implicit `ismaster`\n\n\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined;\n      failureHandler(err);\n      return;\n    }\n\n    if (monitor.s.state === STATE_CLOSING || monitor.s.state === STATE_CLOSED) {\n      conn.destroy({\n        force: true\n      });\n      failureHandler(new MongoError('monitor was destroyed'));\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    successHandler(conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  stateTransition(monitor, STATE_MONITORING); // TODO: the next line is a legacy event, remove in v4\n\n  process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n  checkServer(monitor, e0 => {\n    if (e0 == null) {\n      rescheduleMonitoring(monitor);\n      return;\n    } // otherwise an error occured on initial discovery, also bail\n\n\n    if (monitor[kServer].description.type === ServerType.Unknown) {\n      monitor.emit('resetServer', e0);\n      rescheduleMonitoring(monitor);\n      return;\n    } // According to the SDAM specification's \"Network error during server check\" section, if\n    // an ismaster call fails we reset the server's pool. If a server was once connected,\n    // change its type to `Unknown` only after retrying once.\n\n\n    monitor.emit('resetConnectionPool');\n    checkServer(monitor, e1 => {\n      if (e1) {\n        monitor.emit('resetServer', e1);\n      }\n\n      rescheduleMonitoring(monitor);\n    });\n  });\n}\n\nfunction rescheduleMonitoring(monitor, ms) {\n  const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;\n\n  if (monitor.s.state === STATE_CLOSING || monitor.s.state === STATE_CLOSED) {\n    return;\n  }\n\n  stateTransition(monitor, STATE_IDLE);\n  monitor[kLastCheckTime] = process.hrtime();\n  monitor[kMonitorId] = setTimeout(() => {\n    monitor[kMonitorId] = undefined;\n    monitor.requestCheck();\n  }, ms || heartbeatFrequencyMS);\n}\n\nmodule.exports = {\n  Monitor\n};","map":null,"metadata":{},"sourceType":"script"}